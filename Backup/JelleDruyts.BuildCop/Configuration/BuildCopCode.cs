//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace JelleDruyts.BuildCop.Configuration
{
    /// <summary>
    /// The configuration settings for BuildCop.
    /// </summary>
	public partial class BuildCopConfiguration : global::System.Configuration.ConfigurationSection
	{
		#region BuildGroups Property
		
        /// <summary>
        /// The XML name of the <see cref="BuildGroups"/> property.
        /// </summary>
		internal const string BuildGroupsPropertyName = "buildGroups";
		
		/// <summary>
		/// Gets the build groups.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(BuildGroupsPropertyName, IsRequired = true, IsKey = false, IsDefaultCollection = false)]
		public BuildGroupCollection BuildGroups
		{
			get
			{
				return (BuildGroupCollection)base[BuildGroupsPropertyName];
			}
		}
		
		#endregion

		#region SharedRules Property
		
        /// <summary>
        /// The XML name of the <see cref="SharedRules"/> property.
        /// </summary>
		internal const string SharedRulesPropertyName = "sharedRules";
		
		/// <summary>
		/// Gets the shared rules.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(SharedRulesPropertyName, IsRequired = false, IsKey = false, IsDefaultCollection = false)]
		public RuleCollection SharedRules
		{
			get
			{
				return (RuleCollection)base[SharedRulesPropertyName];
			}
		}
		
		#endregion

		#region Formatters Property
		
        /// <summary>
        /// The XML name of the <see cref="Formatters"/> property.
        /// </summary>
		internal const string FormattersPropertyName = "formatters";
		
		/// <summary>
		/// Gets the formatters.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(FormattersPropertyName, IsRequired = true, IsKey = false, IsDefaultCollection = false)]
		public FormatterCollection Formatters
		{
			get
			{
				return (FormatterCollection)base[FormattersPropertyName];
			}
		}
		
		#endregion

		#region OutputTypeMappings Property
		
        /// <summary>
        /// The XML name of the <see cref="OutputTypeMappings"/> property.
        /// </summary>
		internal const string OutputTypeMappingsPropertyName = "outputTypeMappings";
		
		/// <summary>
		/// Gets the output type mappings.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(OutputTypeMappingsPropertyName, IsRequired = false, IsKey = false, IsDefaultCollection = false)]
		public OutputTypeCollection OutputTypeMappings
		{
			get
			{
				return (OutputTypeCollection)base[OutputTypeMappingsPropertyName];
			}
		}
		
		#endregion

        #region Singleton Instance

        /// <summary>
        /// The XML name of the BuildCopConfiguration Configuration Section.
        /// </summary>
		internal const string BuildCopConfigurationSectionName = "buildCopConfiguration";

        /// <summary>
        /// Gets the BuildCopConfiguration instance.
        /// </summary>
        public static BuildCopConfiguration Instance
        {
            get
            {
                return global::System.Configuration.ConfigurationManager.GetSection(BuildCopConfigurationSectionName) as BuildCopConfiguration;
            }
        }

        #endregion

		#region Xmlns Property
		
        /// <summary>
        /// The XML name of the <see cref="Xmlns"/> property.
        /// </summary>
		internal const string XmlnsPropertyName = "xmlns";
		
		/// <summary>
		/// Gets the XML namespace of this Configuration Section.
		/// </summary>
		/// <remarks>
		/// This property makes sure that if the configuration file contains the XML namespace,
		/// the parser doesn't throw an exception because it encounters the unknown "xmlns" attribute.
		/// </remarks>
		[global::System.Configuration.ConfigurationProperty(XmlnsPropertyName, IsRequired = false, IsKey = false, IsDefaultCollection = false)]
		public string Xmlns
		{
			get
			{
				return (string)base[XmlnsPropertyName];
			}
		}
		
		#endregion
	}

    /// <summary>
    /// Defines a build group.
    /// </summary>
	public partial class BuildGroupElement : global::System.Configuration.ConfigurationElement
	{
		#region Name Property
		
        /// <summary>
        /// The XML name of the <see cref="Name"/> property.
        /// </summary>
		internal const string NamePropertyName = "name";
		
		/// <summary>
		/// Gets or sets the name of this build group.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(NamePropertyName, IsRequired = true, IsKey = true, IsDefaultCollection = false)]
		public System.String Name
		{
			get
			{
				return (System.String)base[NamePropertyName];
			}
			set
			{
				base[NamePropertyName] = value;
			}
		}
		
		#endregion

		#region Enabled Property
		
        /// <summary>
        /// The XML name of the <see cref="Enabled"/> property.
        /// </summary>
		internal const string EnabledPropertyName = "enabled";
		
		/// <summary>
		/// Gets or sets a value that determines if this build group is enabled.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(EnabledPropertyName, IsRequired = false, IsKey = false, IsDefaultCollection = false, DefaultValue = true)]
		public System.Boolean Enabled
		{
			get
			{
				return (System.Boolean)base[EnabledPropertyName];
			}
			set
			{
				base[EnabledPropertyName] = value;
			}
		}
		
		#endregion

		#region BuildFiles Property
		
        /// <summary>
        /// The XML name of the <see cref="BuildFiles"/> property.
        /// </summary>
		internal const string BuildFilesPropertyName = "buildFiles";
		
		/// <summary>
		/// Gets the build files in this build group.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(BuildFilesPropertyName, IsRequired = true, IsKey = false, IsDefaultCollection = false)]
		public BuildFilesElement BuildFiles
		{
			get
			{
				return (BuildFilesElement)base[BuildFilesPropertyName];
			}
		}
		
		#endregion

		#region Rules Property
		
        /// <summary>
        /// The XML name of the <see cref="Rules"/> property.
        /// </summary>
		internal const string RulesPropertyName = "rules";
		
		/// <summary>
		/// Gets the rules in this build group.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(RulesPropertyName, IsRequired = true, IsKey = false, IsDefaultCollection = false)]
		public RuleCollection Rules
		{
			get
			{
				return (RuleCollection)base[RulesPropertyName];
			}
		}
		
		#endregion

	}

    /// <summary>
    /// A collection of BuildGroupElement instances.
    /// </summary>
    [global::System.Configuration.ConfigurationCollection(typeof(BuildGroupElement), CollectionType = global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName = BuildGroupCollection.BuildGroupElementPropertyName)]
	public partial class BuildGroupCollection : global::System.Configuration.ConfigurationElementCollection
	{
		#region Constants
		
        /// <summary>
        /// The XML name of the individual <see cref="BuildGroupElement"/> instances in this collection.
        /// </summary>
		internal const string BuildGroupElementPropertyName = "buildGroup";

		#endregion
        
        #region Overrides

        /// <summary>
        /// Gets the type of the <see cref="T:System.Configuration.ConfigurationElementCollection"></see>.
        /// </summary>
        /// <value></value>
        /// <returns>The <see cref="T:System.Configuration.ConfigurationElementCollectionType"></see> of this collection.</returns>
        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;
            }
        }

        /// <summary>
        /// Indicates whether the specified <see cref="T:System.Configuration.ConfigurationElement"></see> exists in the <see cref="T:System.Configuration.ConfigurationElementCollection"></see>.
        /// </summary>
        /// <param name="elementName">The name of the element to verify.</param>
        /// <returns>
        /// true if the element exists in the collection; otherwise, false. The default is false.
        /// </returns>
        protected override bool IsElementName(string elementName)
        {
            return (elementName == BuildGroupElementPropertyName);
        }

        /// <summary>
        /// Gets the element key for a specified configuration element when overridden in a derived class.
        /// </summary>
        /// <param name="element">The <see cref="T:System.Configuration.ConfigurationElement"></see> to return the key for.</param>
        /// <returns>
        /// An <see cref="T:System.Object"></see> that acts as the key for the specified <see cref="T:System.Configuration.ConfigurationElement"></see>.
        /// </returns>
        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)
        {
            return ((BuildGroupElement)element).Name;
        }

        /// <summary>
        /// When overridden in a derived class, creates a new <see cref="T:System.Configuration.ConfigurationElement"></see>.
        /// </summary>
        /// <returns>
        /// A new <see cref="T:System.Configuration.ConfigurationElement"></see>.
        /// </returns>
        protected override global::System.Configuration.ConfigurationElement CreateNewElement()
        {
            return new BuildGroupElement();
        }

        #endregion        
		
        #region Indexer

        /// <summary>
        /// Gets the <see cref="BuildGroupElement"/> at the specified index.
        /// </summary>
        /// <param name="index">The index of the <see cref="BuildGroupElement"/> to retrieve</param>
        public BuildGroupElement this[int index]
        {
            get
            {
				return (BuildGroupElement)this.BaseGet(index);
			}
        }

        #endregion
		
        #region Add

        /// <summary>
        /// Adds the specified BuildGroupElement.
        /// </summary>
        /// <param name="buildGroup">The BuildGroupElement to add.</param>
        public void Add(BuildGroupElement buildGroup)
        {
            base.BaseAdd(buildGroup);
        }

        #endregion
	}

    /// <summary>
    /// A collection of FormatterElement instances.
    /// </summary>
    [global::System.Configuration.ConfigurationCollection(typeof(FormatterElement), CollectionType = global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName = FormatterCollection.FormatterElementPropertyName)]
	public partial class FormatterCollection : global::System.Configuration.ConfigurationElementCollection
	{
		#region Constants
		
        /// <summary>
        /// The XML name of the individual <see cref="FormatterElement"/> instances in this collection.
        /// </summary>
		internal const string FormatterElementPropertyName = "formatter";

		#endregion
        
        #region Overrides

        /// <summary>
        /// Gets the type of the <see cref="T:System.Configuration.ConfigurationElementCollection"></see>.
        /// </summary>
        /// <value></value>
        /// <returns>The <see cref="T:System.Configuration.ConfigurationElementCollectionType"></see> of this collection.</returns>
        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;
            }
        }

        /// <summary>
        /// Indicates whether the specified <see cref="T:System.Configuration.ConfigurationElement"></see> exists in the <see cref="T:System.Configuration.ConfigurationElementCollection"></see>.
        /// </summary>
        /// <param name="elementName">The name of the element to verify.</param>
        /// <returns>
        /// true if the element exists in the collection; otherwise, false. The default is false.
        /// </returns>
        protected override bool IsElementName(string elementName)
        {
            return (elementName == FormatterElementPropertyName);
        }

        /// <summary>
        /// Gets the element key for a specified configuration element when overridden in a derived class.
        /// </summary>
        /// <param name="element">The <see cref="T:System.Configuration.ConfigurationElement"></see> to return the key for.</param>
        /// <returns>
        /// An <see cref="T:System.Object"></see> that acts as the key for the specified <see cref="T:System.Configuration.ConfigurationElement"></see>.
        /// </returns>
        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)
        {
            return ((FormatterElement)element).Name;
        }

        /// <summary>
        /// When overridden in a derived class, creates a new <see cref="T:System.Configuration.ConfigurationElement"></see>.
        /// </summary>
        /// <returns>
        /// A new <see cref="T:System.Configuration.ConfigurationElement"></see>.
        /// </returns>
        protected override global::System.Configuration.ConfigurationElement CreateNewElement()
        {
            return new FormatterElement();
        }

        #endregion        
		
        #region Indexer

        /// <summary>
        /// Gets the <see cref="FormatterElement"/> at the specified index.
        /// </summary>
        /// <param name="index">The index of the <see cref="FormatterElement"/> to retrieve</param>
        public FormatterElement this[int index]
        {
            get
            {
				return (FormatterElement)this.BaseGet(index);
			}
        }

        #endregion
		
        #region Add

        /// <summary>
        /// Adds the specified FormatterElement.
        /// </summary>
        /// <param name="formatter">The FormatterElement to add.</param>
        public void Add(FormatterElement formatter)
        {
            base.BaseAdd(formatter);
        }

        #endregion
	}

    /// <summary>
    /// Defines a formatter for a BuildCop report.
    /// </summary>
	public partial class FormatterElement : global::System.Configuration.ConfigurationElement
	{
		#region Name Property
		
        /// <summary>
        /// The XML name of the <see cref="Name"/> property.
        /// </summary>
		internal const string NamePropertyName = "name";
		
		/// <summary>
		/// Gets or sets the name of this formatter.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(NamePropertyName, IsRequired = true, IsKey = true, IsDefaultCollection = false)]
		public System.String Name
		{
			get
			{
				return (System.String)base[NamePropertyName];
			}
			set
			{
				base[NamePropertyName] = value;
			}
		}
		
		#endregion

		#region Type Property
		
        /// <summary>
        /// The XML name of the <see cref="Type"/> property.
        /// </summary>
		internal const string TypePropertyName = "type";
		
		/// <summary>
		/// Gets or sets the type of this formatter.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(TypePropertyName, IsRequired = true, IsKey = false, IsDefaultCollection = false)]
		public System.String Type
		{
			get
			{
				return (System.String)base[TypePropertyName];
			}
			set
			{
				base[TypePropertyName] = value;
			}
		}
		
		#endregion

		#region MinimumLogLevel Property
		
        /// <summary>
        /// The XML name of the <see cref="MinimumLogLevel"/> property.
        /// </summary>
		internal const string MinimumLogLevelPropertyName = "minimumLogLevel";
		
		/// <summary>
		/// Gets or sets the minimum log level this formatter should display.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(MinimumLogLevelPropertyName, IsRequired = false, IsKey = false, IsDefaultCollection = false, DefaultValue = JelleDruyts.BuildCop.Reporting.LogLevel.Information)]
		public JelleDruyts.BuildCop.Reporting.LogLevel MinimumLogLevel
		{
			get
			{
				return (JelleDruyts.BuildCop.Reporting.LogLevel)base[MinimumLogLevelPropertyName];
			}
			set
			{
				base[MinimumLogLevelPropertyName] = value;
			}
		}
		
		#endregion

		#region Custom Child Elements

		/// <summary>
		/// Gets a value indicating whether an unknown element is encountered during deserialization.
		/// </summary>
		/// <param name="elementName">The name of the unknown subelement.</param>
		/// <param name="reader">The <see cref="T:System.Xml.XmlReader"/> being used for deserialization.</param>
		/// <returns>
		/// <see langword="true"/> when an unknown element is encountered while deserializing; otherwise, <see langword="false"/>.
		/// </returns>
		/// <exception cref="T:System.Configuration.ConfigurationErrorsException">The element identified by <paramref name="elementName"/> is locked.- or -One or more of the element's attributes is locked.- or -<paramref name="elementName"/> is unrecognized, or the element has an unrecognized attribute.- or -The element has a Boolean attribute with an invalid value.- or -An attempt was made to deserialize a property more than once.- or -An attempt was made to deserialize a property that is not a valid member of the element.- or -The element cannot contain a CDATA or text element.</exception>
		protected override global::System.Boolean OnDeserializeUnrecognizedElement(global::System.String elementName, global::System.Xml.XmlReader reader)
		{
			// IMPORTANT NOTE: The code below does not build by default.
			// You have indicated that this configuration element has
			// custom child elements. Implement the logic to handle unknown
			// deserialized elements by declaring a new method with the
			// signature below in a partial class definition for this element:
			
			// private bool HandleUnrecognizedElement(string elementName, XmlReader reader)
			
			return HandleUnrecognizedElement(elementName, reader);
		}

		#endregion

	}

    /// <summary>
    /// A collection of RuleElement instances.
    /// </summary>
    [global::System.Configuration.ConfigurationCollection(typeof(RuleElement), CollectionType = global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName = RuleCollection.RuleElementPropertyName)]
	public partial class RuleCollection : global::System.Configuration.ConfigurationElementCollection
	{
		#region Constants
		
        /// <summary>
        /// The XML name of the individual <see cref="RuleElement"/> instances in this collection.
        /// </summary>
		internal const string RuleElementPropertyName = "rule";

		#endregion
        
        #region Overrides

        /// <summary>
        /// Gets the type of the <see cref="T:System.Configuration.ConfigurationElementCollection"></see>.
        /// </summary>
        /// <value></value>
        /// <returns>The <see cref="T:System.Configuration.ConfigurationElementCollectionType"></see> of this collection.</returns>
        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;
            }
        }

        /// <summary>
        /// Indicates whether the specified <see cref="T:System.Configuration.ConfigurationElement"></see> exists in the <see cref="T:System.Configuration.ConfigurationElementCollection"></see>.
        /// </summary>
        /// <param name="elementName">The name of the element to verify.</param>
        /// <returns>
        /// true if the element exists in the collection; otherwise, false. The default is false.
        /// </returns>
        protected override bool IsElementName(string elementName)
        {
            return (elementName == RuleElementPropertyName);
        }

        /// <summary>
        /// Gets the element key for a specified configuration element when overridden in a derived class.
        /// </summary>
        /// <param name="element">The <see cref="T:System.Configuration.ConfigurationElement"></see> to return the key for.</param>
        /// <returns>
        /// An <see cref="T:System.Object"></see> that acts as the key for the specified <see cref="T:System.Configuration.ConfigurationElement"></see>.
        /// </returns>
        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)
        {
            return ((RuleElement)element).Name;
        }

        /// <summary>
        /// When overridden in a derived class, creates a new <see cref="T:System.Configuration.ConfigurationElement"></see>.
        /// </summary>
        /// <returns>
        /// A new <see cref="T:System.Configuration.ConfigurationElement"></see>.
        /// </returns>
        protected override global::System.Configuration.ConfigurationElement CreateNewElement()
        {
            return new RuleElement();
        }

        #endregion        
		
        #region Indexer

        /// <summary>
        /// Gets the <see cref="RuleElement"/> at the specified index.
        /// </summary>
        /// <param name="index">The index of the <see cref="RuleElement"/> to retrieve</param>
        public RuleElement this[int index]
        {
            get
            {
				return (RuleElement)this.BaseGet(index);
			}
        }

        #endregion
		
        #region Add

        /// <summary>
        /// Adds the specified RuleElement.
        /// </summary>
        /// <param name="rule">The RuleElement to add.</param>
        public void Add(RuleElement rule)
        {
            base.BaseAdd(rule);
        }

        #endregion
	}

    /// <summary>
    /// A collection of OutputTypeElement instances.
    /// </summary>
    [global::System.Configuration.ConfigurationCollection(typeof(OutputTypeElement), CollectionType = global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName = OutputTypeCollection.OutputTypeElementPropertyName)]
	public partial class OutputTypeCollection : global::System.Configuration.ConfigurationElementCollection
	{
		#region Constants
		
        /// <summary>
        /// The XML name of the individual <see cref="OutputTypeElement"/> instances in this collection.
        /// </summary>
		internal const string OutputTypeElementPropertyName = "outputType";

		#endregion
        
        #region Overrides

        /// <summary>
        /// Gets the type of the <see cref="T:System.Configuration.ConfigurationElementCollection"></see>.
        /// </summary>
        /// <value></value>
        /// <returns>The <see cref="T:System.Configuration.ConfigurationElementCollectionType"></see> of this collection.</returns>
        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;
            }
        }

        /// <summary>
        /// Indicates whether the specified <see cref="T:System.Configuration.ConfigurationElement"></see> exists in the <see cref="T:System.Configuration.ConfigurationElementCollection"></see>.
        /// </summary>
        /// <param name="elementName">The name of the element to verify.</param>
        /// <returns>
        /// true if the element exists in the collection; otherwise, false. The default is false.
        /// </returns>
        protected override bool IsElementName(string elementName)
        {
            return (elementName == OutputTypeElementPropertyName);
        }

        /// <summary>
        /// Gets the element key for a specified configuration element when overridden in a derived class.
        /// </summary>
        /// <param name="element">The <see cref="T:System.Configuration.ConfigurationElement"></see> to return the key for.</param>
        /// <returns>
        /// An <see cref="T:System.Object"></see> that acts as the key for the specified <see cref="T:System.Configuration.ConfigurationElement"></see>.
        /// </returns>
        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)
        {
            return ((OutputTypeElement)element).Alias;
        }

        /// <summary>
        /// When overridden in a derived class, creates a new <see cref="T:System.Configuration.ConfigurationElement"></see>.
        /// </summary>
        /// <returns>
        /// A new <see cref="T:System.Configuration.ConfigurationElement"></see>.
        /// </returns>
        protected override global::System.Configuration.ConfigurationElement CreateNewElement()
        {
            return new OutputTypeElement();
        }

        #endregion        
		
        #region Indexer

        /// <summary>
        /// Gets the <see cref="OutputTypeElement"/> at the specified index.
        /// </summary>
        /// <param name="index">The index of the <see cref="OutputTypeElement"/> to retrieve</param>
        public OutputTypeElement this[int index]
        {
            get
            {
				return (OutputTypeElement)this.BaseGet(index);
			}
        }

        #endregion
		
        #region Add

        /// <summary>
        /// Adds the specified OutputTypeElement.
        /// </summary>
        /// <param name="outputType">The OutputTypeElement to add.</param>
        public void Add(OutputTypeElement outputType)
        {
            base.BaseAdd(outputType);
        }

        #endregion
	}

    /// <summary>
    /// Defines an output type alias for a project type GUID.
    /// </summary>
	public partial class OutputTypeElement : global::System.Configuration.ConfigurationElement
	{
		#region Alias Property
		
        /// <summary>
        /// The XML name of the <see cref="Alias"/> property.
        /// </summary>
		internal const string AliasPropertyName = "alias";
		
		/// <summary>
		/// Gets or sets the alias of this output type.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(AliasPropertyName, IsRequired = true, IsKey = true, IsDefaultCollection = false)]
		public System.String Alias
		{
			get
			{
				return (System.String)base[AliasPropertyName];
			}
			set
			{
				base[AliasPropertyName] = value;
			}
		}
		
		#endregion

		#region ProjectTypeGuid Property
		
        /// <summary>
        /// The XML name of the <see cref="ProjectTypeGuid"/> property.
        /// </summary>
		internal const string ProjectTypeGuidPropertyName = "projectTypeGuid";
		
		/// <summary>
		/// Gets or sets the project type GUID of this output type alias.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(ProjectTypeGuidPropertyName, IsRequired = true, IsKey = false, IsDefaultCollection = false)]
		public System.String ProjectTypeGuid
		{
			get
			{
				return (System.String)base[ProjectTypeGuidPropertyName];
			}
			set
			{
				base[ProjectTypeGuidPropertyName] = value;
			}
		}
		
		#endregion

	}

    /// <summary>
    /// Defines a rule.
    /// </summary>
	public partial class RuleElement : global::System.Configuration.ConfigurationElement
	{
		#region Name Property
		
        /// <summary>
        /// The XML name of the <see cref="Name"/> property.
        /// </summary>
		internal const string NamePropertyName = "name";
		
		/// <summary>
		/// Gets or sets the name of this rule.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(NamePropertyName, IsRequired = true, IsKey = true, IsDefaultCollection = false)]
		public System.String Name
		{
			get
			{
				return (System.String)base[NamePropertyName];
			}
			set
			{
				base[NamePropertyName] = value;
			}
		}
		
		#endregion

		#region Type Property
		
        /// <summary>
        /// The XML name of the <see cref="Type"/> property.
        /// </summary>
		internal const string TypePropertyName = "type";
		
		/// <summary>
		/// Gets or sets the type of this rule.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(TypePropertyName, IsRequired = false, IsKey = false, IsDefaultCollection = false)]
		public System.String Type
		{
			get
			{
				return (System.String)base[TypePropertyName];
			}
			set
			{
				base[TypePropertyName] = value;
			}
		}
		
		#endregion

		#region ExcludedFiles Property
		
        /// <summary>
        /// The XML name of the <see cref="ExcludedFiles"/> property.
        /// </summary>
		internal const string ExcludedFilesPropertyName = "excludedFiles";
		
		/// <summary>
		/// Gets or sets the string to find in the names of files to exclude for this rule.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(ExcludedFilesPropertyName, IsRequired = false, IsKey = false, IsDefaultCollection = false)]
		public System.String ExcludedFiles
		{
			get
			{
				return (System.String)base[ExcludedFilesPropertyName];
			}
			set
			{
				base[ExcludedFilesPropertyName] = value;
			}
		}
		
		#endregion

		#region ExcludedOutputTypes Property
		
        /// <summary>
        /// The XML name of the <see cref="ExcludedOutputTypes"/> property.
        /// </summary>
		internal const string ExcludedOutputTypesPropertyName = "excludedOutputTypes";
		
		/// <summary>
		/// Gets or sets the string to find in the output type of files to exclude for this rule.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(ExcludedOutputTypesPropertyName, IsRequired = false, IsKey = false, IsDefaultCollection = false)]
		public System.String ExcludedOutputTypes
		{
			get
			{
				return (System.String)base[ExcludedOutputTypesPropertyName];
			}
			set
			{
				base[ExcludedOutputTypesPropertyName] = value;
			}
		}
		
		#endregion

		#region Enabled Property
		
        /// <summary>
        /// The XML name of the <see cref="Enabled"/> property.
        /// </summary>
		internal const string EnabledPropertyName = "enabled";
		
		/// <summary>
		/// Gets or sets a value that determines if this rule is enabled.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(EnabledPropertyName, IsRequired = false, IsKey = false, IsDefaultCollection = false, DefaultValue = true)]
		public System.Boolean Enabled
		{
			get
			{
				return (System.Boolean)base[EnabledPropertyName];
			}
			set
			{
				base[EnabledPropertyName] = value;
			}
		}
		
		#endregion

		#region Custom Child Elements

		/// <summary>
		/// Gets a value indicating whether an unknown element is encountered during deserialization.
		/// </summary>
		/// <param name="elementName">The name of the unknown subelement.</param>
		/// <param name="reader">The <see cref="T:System.Xml.XmlReader"/> being used for deserialization.</param>
		/// <returns>
		/// <see langword="true"/> when an unknown element is encountered while deserializing; otherwise, <see langword="false"/>.
		/// </returns>
		/// <exception cref="T:System.Configuration.ConfigurationErrorsException">The element identified by <paramref name="elementName"/> is locked.- or -One or more of the element's attributes is locked.- or -<paramref name="elementName"/> is unrecognized, or the element has an unrecognized attribute.- or -The element has a Boolean attribute with an invalid value.- or -An attempt was made to deserialize a property more than once.- or -An attempt was made to deserialize a property that is not a valid member of the element.- or -The element cannot contain a CDATA or text element.</exception>
		protected override global::System.Boolean OnDeserializeUnrecognizedElement(global::System.String elementName, global::System.Xml.XmlReader reader)
		{
			// IMPORTANT NOTE: The code below does not build by default.
			// You have indicated that this configuration element has
			// custom child elements. Implement the logic to handle unknown
			// deserialized elements by declaring a new method with the
			// signature below in a partial class definition for this element:
			
			// private bool HandleUnrecognizedElement(string elementName, XmlReader reader)
			
			return HandleUnrecognizedElement(elementName, reader);
		}

		#endregion

	}

    /// <summary>
    /// Defines the build files to be processed.
    /// </summary>
	public partial class BuildFilesElement : global::System.Configuration.ConfigurationElement
	{
		#region ExcludedFiles Property
		
        /// <summary>
        /// The XML name of the <see cref="ExcludedFiles"/> property.
        /// </summary>
		internal const string ExcludedFilesPropertyName = "excludedFiles";
		
		/// <summary>
		/// Gets or sets the string to find in the names of files to exclude in the given root path.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(ExcludedFilesPropertyName, IsRequired = false, IsKey = false, IsDefaultCollection = false)]
		public System.String ExcludedFiles
		{
			get
			{
				return (System.String)base[ExcludedFilesPropertyName];
			}
			set
			{
				base[ExcludedFilesPropertyName] = value;
			}
		}
		
		#endregion

		#region Paths Property
		
        /// <summary>
        /// The XML name of the <see cref="Paths"/> property.
        /// </summary>
		internal const string PathsPropertyName = "paths";
		
		/// <summary>
		/// Gets the paths to the build files to be processed.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(PathsPropertyName, IsRequired = true, IsKey = false, IsDefaultCollection = false)]
		public BuildFilePathCollection Paths
		{
			get
			{
				return (BuildFilePathCollection)base[PathsPropertyName];
			}
		}
		
		#endregion

	}

    /// <summary>
    /// A collection of BuildFilePathElement instances.
    /// </summary>
    [global::System.Configuration.ConfigurationCollection(typeof(BuildFilePathElement), CollectionType = global::System.Configuration.ConfigurationElementCollectionType.BasicMap, AddItemName = BuildFilePathCollection.BuildFilePathElementPropertyName)]
	public partial class BuildFilePathCollection : global::System.Configuration.ConfigurationElementCollection
	{
		#region Constants
		
        /// <summary>
        /// The XML name of the individual <see cref="BuildFilePathElement"/> instances in this collection.
        /// </summary>
		internal const string BuildFilePathElementPropertyName = "path";

		#endregion
        
        #region Overrides

        /// <summary>
        /// Gets the type of the <see cref="T:System.Configuration.ConfigurationElementCollection"></see>.
        /// </summary>
        /// <value></value>
        /// <returns>The <see cref="T:System.Configuration.ConfigurationElementCollectionType"></see> of this collection.</returns>
        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return global::System.Configuration.ConfigurationElementCollectionType.BasicMap;
            }
        }

        /// <summary>
        /// Indicates whether the specified <see cref="T:System.Configuration.ConfigurationElement"></see> exists in the <see cref="T:System.Configuration.ConfigurationElementCollection"></see>.
        /// </summary>
        /// <param name="elementName">The name of the element to verify.</param>
        /// <returns>
        /// true if the element exists in the collection; otherwise, false. The default is false.
        /// </returns>
        protected override bool IsElementName(string elementName)
        {
            return (elementName == BuildFilePathElementPropertyName);
        }

        /// <summary>
        /// Gets the element key for a specified configuration element when overridden in a derived class.
        /// </summary>
        /// <param name="element">The <see cref="T:System.Configuration.ConfigurationElement"></see> to return the key for.</param>
        /// <returns>
        /// An <see cref="T:System.Object"></see> that acts as the key for the specified <see cref="T:System.Configuration.ConfigurationElement"></see>.
        /// </returns>
        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)
        {
            return ((BuildFilePathElement)element).RootPath;
        }

        /// <summary>
        /// When overridden in a derived class, creates a new <see cref="T:System.Configuration.ConfigurationElement"></see>.
        /// </summary>
        /// <returns>
        /// A new <see cref="T:System.Configuration.ConfigurationElement"></see>.
        /// </returns>
        protected override global::System.Configuration.ConfigurationElement CreateNewElement()
        {
            return new BuildFilePathElement();
        }

        #endregion        
		
        #region Indexer

        /// <summary>
        /// Gets the <see cref="BuildFilePathElement"/> at the specified index.
        /// </summary>
        /// <param name="index">The index of the <see cref="BuildFilePathElement"/> to retrieve</param>
        public BuildFilePathElement this[int index]
        {
            get
            {
				return (BuildFilePathElement)this.BaseGet(index);
			}
        }

        #endregion
		
        #region Add

        /// <summary>
        /// Adds the specified BuildFilePathElement.
        /// </summary>
        /// <param name="path">The BuildFilePathElement to add.</param>
        public void Add(BuildFilePathElement path)
        {
            base.BaseAdd(path);
        }

        #endregion
	}

    /// <summary>
    /// Defines a build file path.
    /// </summary>
	public partial class BuildFilePathElement : global::System.Configuration.ConfigurationElement
	{
		#region RootPath Property
		
        /// <summary>
        /// The XML name of the <see cref="RootPath"/> property.
        /// </summary>
		internal const string RootPathPropertyName = "rootPath";
		
		/// <summary>
		/// Gets or sets the root path to look for build files.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(RootPathPropertyName, IsRequired = true, IsKey = true, IsDefaultCollection = false)]
		public System.String RootPath
		{
			get
			{
				return (System.String)base[RootPathPropertyName];
			}
			set
			{
				base[RootPathPropertyName] = value;
			}
		}
		
		#endregion

		#region SearchPattern Property
		
        /// <summary>
        /// The XML name of the <see cref="SearchPattern"/> property.
        /// </summary>
		internal const string SearchPatternPropertyName = "searchPattern";
		
		/// <summary>
		/// Gets or sets the search string to match against the names of files to include in the given root path.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(SearchPatternPropertyName, IsRequired = false, IsKey = false, IsDefaultCollection = false)]
		public System.String SearchPattern
		{
			get
			{
				return (System.String)base[SearchPatternPropertyName];
			}
			set
			{
				base[SearchPatternPropertyName] = value;
			}
		}
		
		#endregion

		#region ExcludedFiles Property
		
        /// <summary>
        /// The XML name of the <see cref="ExcludedFiles"/> property.
        /// </summary>
		internal const string ExcludedFilesPropertyName = "excludedFiles";
		
		/// <summary>
		/// Gets or sets the string to find in the names of files to exclude in the given root path.
		/// </summary>
		[global::System.Configuration.ConfigurationProperty(ExcludedFilesPropertyName, IsRequired = false, IsKey = false, IsDefaultCollection = false)]
		public System.String ExcludedFiles
		{
			get
			{
				return (System.String)base[ExcludedFilesPropertyName];
			}
			set
			{
				base[ExcludedFilesPropertyName] = value;
			}
		}
		
		#endregion

	}

}

namespace JelleDruyts.BuildCop.Reporting
{
	/// <summary>
	/// Specifies log levels for log entries.
	/// </summary>
	public enum LogLevel
	{
		/// <summary>
		/// The log entry is considered informational.
		/// </summary>
		Information = 0,
		
		/// <summary>
		/// The log entry is considered a warning.
		/// </summary>
		Warning = 1,
		
		/// <summary>
		/// The log entry is considered an error.
		/// </summary>
		Error = 2,
		
		/// <summary>
		/// The log entry is an exception.
		/// </summary>
		Exception = 3
		
	}
}

